export function isSpecial(value) {
    const stringValue = Object.prototype.toString.call(value);
    return stringValue === '[object RegExp]' || stringValue === '[object Date]';
}
export function isNonNullObject(value) {
    return !!value && typeof value === 'object';
}
export function mergeObject(target, source) {
    const destination = {};
    if (isMergeableObject(target)) {
        Object.keys(target).forEach(function (key) {
            destination[key] = clone(target[key]);
        });
    }
    Object.keys(source).forEach(function (key) {
        if (!isMergeableObject(source[key]) || !target[key]) {
            destination[key] = clone(source[key]);
        }
        else {
            destination[key] = merge(target[key], source[key]);
        }
    });
    return destination;
}
export function isMergeableObject(value) {
    return isNonNullObject(value) && !isSpecial(value);
}
export function emptyTarget(val) {
    return Array.isArray(val) ? [] : {};
}
export function arrayMerge(target, source) {
    return target.concat(source).map(function (element) {
        return clone(element);
    });
}
export function clone(value) {
    return isMergeableObject(value) ? merge(emptyTarget(value), value) : value;
}
export function merge(target, source) {
    const sourceIsArray = Array.isArray(source);
    const targetIsArray = Array.isArray(target);
    const sourceAndTargetTypesMatch = sourceIsArray === targetIsArray;
    if (!sourceAndTargetTypesMatch) {
        return clone(source);
    }
    else if (sourceIsArray) {
        return arrayMerge(target, source);
    }
    else {
        return mergeObject(target, source);
    }
}
export function isObject(value) {
    return value !== null && typeof value === 'object';
}
export function handleObjectPath(objPath) {
    let pathParts;
    if (typeof objPath === 'string') {
        pathParts = objPath.split('.');
    }
    else if (objPath && objPath.length) {
        pathParts = objPath;
    }
    else {
        throw new Error('path should be either dotted string or array of strings');
    }
    return pathParts;
}
export function assignValue(objRef, key, value) {
    if (Array.isArray(objRef[key]) && Array.isArray(value)) {
        objRef[key].push(...value);
    }
    else if (isObject(objRef[key]) && isObject(value)) {
        deepMerge(objRef[key], value);
    }
    else {
        objRef[key] = value;
    }
}
export function deepMerge(target, source) {
    for (const key of Object.keys(source)) {
        if (isObject(target[key]) && isObject(source[key])) {
            deepMerge(target[key], source[key]);
        }
        else if (Array.isArray(target[key]) && Array.isArray(source[key])) {
            target[key] = target[key].concat(source[key]);
        }
        else {
            target[key] = source[key];
        }
    }
    return target;
}
export function set(obj, dottedPath, value) {
    const pathParts = handleObjectPath(dottedPath);
    const lastPathPart = pathParts[pathParts.length - 1];
    let objRef = obj;
    for (let i = 0; i < pathParts.length - 1; i++) {
        const pathPart = pathParts[i];
        if (!objRef[pathPart]) {
            objRef[pathPart] = {};
        }
        objRef = objRef[pathPart];
    }
    assignValue(objRef, lastPathPart, value);
    return obj;
}
export function get(obj, dottedPath) {
    const pathParts = handleObjectPath(dottedPath);
    let nested = obj;
    for (let i = 0; i < pathParts.length; i++) {
        if (!nested[pathParts[i]]) {
            return null;
        }
        nested = nested[pathParts[i]];
    }
    return nested;
}
export function capitalize(txt) {
    return txt.charAt(0).toUpperCase() + txt.slice(1);
}
export function lowerCase(txt) {
    return txt.charAt(0).toLowerCase() + txt.slice(1);
}
export function camelToTitle(camelCase) {
    return camelCase
        .replace(/([A-Z]+)/g, (match) => ` ${match}`)
        .trim()
        .replace(/^./, (match) => match.toUpperCase());
}
export function toCamelCase(str, separator) {
    return lowerCase(str.split(separator).map(capitalize).join(''));
}
export function getAllIndexes(str, searchElement) {
    const indexes = [];
    for (let index = 0; index < str.length; index++) {
        if (str[index] === searchElement) {
            indexes.push(index);
        }
    }
    return indexes;
}
//# sourceMappingURL=utils.js.map