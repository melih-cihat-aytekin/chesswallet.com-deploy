import inversify from 'inversify';
import { Container } from '../container/container.js';
import { ConfigManager } from '../components/config/config-manager.js';
import { ClassLoader } from '../fs/class-loader.js';
import { Logger } from '../log/logger.js';
import { AppContext } from './app-context.js';
import { ComponentRegistry } from '../components/component-registry.js';
import { ComponentScope, CoreDecorator } from '../components/enums.js';
import { AppState } from './app.enums.js';
export class App {
    constructor(options) {
        this.classLoader = new ClassLoader(options.components);
        this.inversifyContainer = new inversify.Container({
            defaultScope: options.components.scope || ComponentScope.SINGLETON
        });
        this.container = new Container(this.inversifyContainer);
        this.componentRegistry = new ComponentRegistry(this.container);
        this.extensions = options.extensions;
        this.logOptions = options.logs || {};
        this.configOptions = options.config;
        this.hooks = [];
        this.appState = AppState.NONE;
    }
    async start() {
        if (this.appState === AppState.STARTED)
            return;
        this.appState = AppState.STARTED;
        this.initHooks();
        for (const hook of this.hooks) {
            if (hook.onStart) {
                await hook.onStart();
            }
        }
        if (this.appSettings && !this.appSettings.disableBootstrapMetrics) {
            const time = process.hrtime(this.startedAt);
            const ms = Math.round((time[0] * 1000) + (time[1] / 1000000));
            this.logger.info(`App Started in ${ms}ms`);
        }
    }
    async stop() {
        if (this.appState === AppState.STOPPED)
            return;
        this.appState = AppState.STOPPED;
        for (const hook of this.hooks) {
            if (hook.onStop) {
                await hook.onStop();
            }
        }
    }
    async init(options) {
        if (this.appState === AppState.INITIATED)
            return;
        this.appState = AppState.INITIATED;
        if (options.mode === 'app') {
            this.appSettings = options.appSettings;
        }
        else if (options.mode === 'ext') {
            this.logOptions = { ...options.logs, prefix: this.logOptions.prefix || 'EXT' };
            this.appContext = options.appContext;
        }
        const bootstrapLogs = options.mode === 'app' && (this.appSettings && !this.appSettings.disableBootstrapMetrics);
        if (bootstrapLogs)
            this.startedAt = process.hrtime();
        this.loadCoreComponents();
        await this.loadExtensions();
        this.registerExtensions();
        await this.loadComponents();
        if (bootstrapLogs) {
            const componentsCount = this.componentRegistry.count();
            const extensionsCount = this.extensions?.length || 0;
            const hooksCount = this.componentRegistry
                .get({ id: CoreDecorator.HOOK }).length;
            const end = process.hrtime(this.startedAt);
            const time = Math.round((end[0] * 1000) + (end[1] / 1000000));
            this.logger.info(`${componentsCount} Components, ${extensionsCount} Extensions, ${hooksCount} Hooks Loaded in ${time}ms`);
        }
    }
    getContainer() {
        return this.container;
    }
    getComponentRegistry() {
        return this.componentRegistry;
    }
    getSettings() {
        if (!this.appSettings)
            throw new Error('App Settings is not available before calling init() on the App');
        return this.appSettings;
    }
    getName() {
        return this.appSettings?.name || this.constructor.name;
    }
    loadCoreComponents() {
        this.logger = new Logger(this.logOptions);
        if (!this.appContext) {
            this.appContext = this;
        }
        this.container.bindConstant(Logger, this.logger);
        this.container.bindConstant(AppContext, this.appContext);
        this.container.bindConstant(ConfigManager, new ConfigManager(this.configOptions));
    }
    async loadExtensions() {
        if (this.extensions) {
            for (const extension of this.extensions) {
                try {
                    await extension.init({
                        mode: 'ext',
                        logs: this.logOptions,
                        appContext: this.appContext
                    });
                }
                catch (e) {
                    throw new Error(`While trying to register Extension ${extension.getName()} - ${e.message}`);
                }
            }
        }
    }
    registerExtensions() {
        if (this.extensions) {
            this.extensions.forEach(ext => {
                this.componentRegistry.registerExtension(ext.getComponentRegistry(), ext.getContainer());
            });
        }
    }
    async loadComponents() {
        await this.classLoader.load();
        this.componentRegistry.register(this.classLoader.classes);
    }
    initHooks() {
        this.hooks = this.componentRegistry
            .get({ id: CoreDecorator.HOOK })
            .map(compInfo => compInfo.getInstance());
    }
}
App.nodearch = true;
//# sourceMappingURL=app.js.map