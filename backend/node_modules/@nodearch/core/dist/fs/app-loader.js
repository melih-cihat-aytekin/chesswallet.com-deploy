import { pathToFileURL } from 'node:url';
import { AppLoadMode } from './enums.js';
import { FileLoader } from './file-loader.js';
import { UrlParser } from './url-parser.js';
export class AppLoader {
    constructor(options) {
        this.isAppDir = false;
        this.cwd = options?.cwd || pathToFileURL(process.cwd());
        this.tsConfigName = options?.tsConfig || 'tsconfig.json';
        this.pkgUrl = UrlParser.join(this.cwd, 'package.json');
        this.tsConfigUrl = UrlParser.join(this.cwd, this.tsConfigName);
        this.nodeModulesDir = UrlParser.join(this.cwd, 'node_modules');
        this.loadMode = options?.loadMode || AppLoadMode.JS;
        this.appEntry = options?.appEntry || 'main';
        this.args = options?.args || [];
        this.initMode = options?.initMode || 'none';
    }
    async load() {
        const pkgInfo = await this.getPkg();
        if (!pkgInfo)
            return;
        this.isAppDir = true;
        this.appSettings = await this.getAppSettings(pkgInfo);
        const loadedModule = await FileLoader.importModule(this.appSettings.paths.app);
        const AppClass = this.getAppObject(loadedModule);
        if (AppClass) {
            this.app = (new AppClass(...this.args));
            if (this.initMode === 'init' || this.initMode === 'start') {
                await this.app.init({
                    mode: 'app',
                    appSettings: this.appSettings
                });
            }
            if (this.initMode === 'start') {
                await this.app.start();
            }
            return {
                app: this.app,
                appSettings: this.appSettings
            };
        }
    }
    async getPkg() {
        const pkgInfo = await FileLoader.importJSON(this.pkgUrl);
        return pkgInfo && pkgInfo.nodearch ? pkgInfo : undefined;
    }
    async getAppSettings(pkgInfo) {
        const tsConfig = await FileLoader.importJSON(this.tsConfigUrl, true);
        let appDir;
        if (this.loadMode === AppLoadMode.TS) {
            appDir = UrlParser.join(this.cwd, tsConfig.compilerOptions.rootDir || 'src');
        }
        else {
            appDir = UrlParser.join(this.cwd, tsConfig.compilerOptions.outDir || 'dist');
        }
        const app = UrlParser.join(appDir, this.appEntry + '.' + this.loadMode);
        const appInfo = {
            name: pkgInfo.name,
            version: pkgInfo.version,
            loadMode: this.loadMode,
            paths: {
                rootDir: this.cwd,
                nodeModulesDir: this.nodeModulesDir,
                pkg: this.pkgUrl,
                tsConfig: this.tsConfigUrl,
                appDir,
                app
            },
            disableBootstrapMetrics: pkgInfo.nodearch.disableBootstrapMetrics || false
        };
        return appInfo;
    }
    getAppObject(moduleObj) {
        if (moduleObj.nodearch)
            return moduleObj;
        if (moduleObj.default?.nodearch)
            return moduleObj.default;
        const key = Object.keys(moduleObj).find(key => {
            if (moduleObj[key].nodearch)
                return true;
        });
        if (key)
            return moduleObj[key];
    }
}
//# sourceMappingURL=app-loader.js.map