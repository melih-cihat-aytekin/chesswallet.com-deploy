import path from 'node:path';
import fs from 'node:fs/promises';
import { FileType } from './enums.js';
import { fileURLToPath } from 'node:url';
import { UrlParser } from './url-parser.js';
export class FileLoader {
    static async loadFiles(filesInfo) {
        return Promise.all(filesInfo.map(async (fileInfo) => {
            const fileContent = await FileLoader.importModule(fileInfo.url);
            fileInfo.content = fileContent;
            return fileInfo;
        }));
    }
    static filterFiles(filesInfo, include, exclude) {
        return filesInfo.filter(item => {
            return FileLoader.isFileNameMatching(item.base, include, exclude);
        });
    }
    static async getDirContent(url) {
        const dirContent = await fs.readdir(url);
        return Promise.all(dirContent.map(async (item) => {
            const itemUrl = UrlParser.join(url, item);
            const itemPath = fileURLToPath(itemUrl);
            const parsedPath = path.parse(itemPath);
            let itemType;
            const stat = await FileLoader.getPathInfo(itemUrl);
            if (!stat) {
                throw new Error(`Couldn't scan the file with path: ${itemPath}`);
            }
            if (stat.isDirectory()) {
                itemType = FileType.Directory;
            }
            else if (stat.isFile()) {
                itemType = FileType.File;
            }
            else {
                itemType = FileType.Other;
            }
            return {
                url: itemUrl,
                path: itemPath,
                ...parsedPath,
                type: itemType
            };
        }));
    }
    static async getFilesList(dirUrl, depth = 1) {
        if (depth <= 0) {
            return [];
        }
        let content = [];
        const dirContent = await FileLoader.getDirContent(dirUrl);
        content = content.concat(...await Promise.all(dirContent.map(async (file) => {
            if (file.type === FileType.Directory) {
                return [file, ...await FileLoader.getFilesList(file.url, depth - 1)];
            }
            else {
                return [file];
            }
        })));
        return content;
    }
    static getFileNameMatcher(exp) {
        return new RegExp(`^${exp.replace(/[.+\-?^${}()|[\]\\]/g, '\\$&').replace(/\*/g, '[^\\n]+')}$`, 'g');
    }
    static isFileNameMatching(fileName, include, exclude) {
        const isExcluded = exclude.some((exp) => {
            const rgx = exp instanceof RegExp ? exp : FileLoader.getFileNameMatcher(exp);
            return fileName.match(rgx);
        });
        if (isExcluded)
            return false;
        return include.some((exp) => {
            const rgx = exp instanceof RegExp ? exp : FileLoader.getFileNameMatcher(exp);
            return fileName.match(rgx);
        });
    }
    static async importModule(url) {
        return await import(url.href);
    }
    static async importJSON(url, jsonComments = false) {
        let jsonStr;
        if (jsonComments) {
            jsonStr = (await fs.readFile(url, 'utf8'))
                .replace(/\/\/.*/g, '')
                .replace(/\/\*.*?\*\//gs, '')
                .replace(/\s+/g, '');
        }
        else {
            jsonStr = await fs.readFile(url, 'utf8');
        }
        return JSON.parse(jsonStr);
    }
    static async getPathInfo(url) {
        let stats;
        try {
            stats = await fs.lstat(fileURLToPath(url));
        }
        catch (e) {
            if (e.code !== 'ENOENT') {
                throw e;
            }
        }
        return stats;
    }
}
//# sourceMappingURL=file-loader.js.map