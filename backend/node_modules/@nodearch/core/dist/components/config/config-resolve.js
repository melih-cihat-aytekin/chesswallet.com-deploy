import { TypeParser } from './type-parser.js';
import * as utils from '../../utils/utils.js';
export class ConfigResolve {
    static hasValue(x) {
        return x !== undefined;
    }
    static env(envConfig, currentEnv, externalConfig) {
        let defaultValue, envValue, externalValue;
        if (envConfig.defaults && Object.keys(envConfig.defaults).length) {
            defaultValue = envConfig.defaults.hasOwnProperty(currentEnv) ?
                envConfig.defaults[currentEnv] : envConfig.defaults['all'];
        }
        if (envConfig.key) {
            const value = process.env[envConfig.key];
            if (ConfigResolve.hasValue(value)) {
                envValue = TypeParser.parse(value, defaultValue, envConfig.dataType);
            }
        }
        if (!ConfigResolve.hasValue(envValue) && (envConfig.external && externalConfig)) {
            externalValue = utils.get(externalConfig, envConfig.external) || undefined;
        }
        const value = ConfigResolve.hasValue(envValue) ? envValue :
            ConfigResolve.hasValue(externalValue) ?
                externalValue : defaultValue;
        if (ConfigResolve.hasValue(value) || !envConfig.required) {
            return value;
        }
        else {
            throw new Error(`Unable to resolve required config key!`);
        }
    }
}
//# sourceMappingURL=config-resolve.js.map