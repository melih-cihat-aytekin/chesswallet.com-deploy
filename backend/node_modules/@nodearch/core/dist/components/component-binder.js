import { isAsyncFunction } from 'node:util/types';
import { CoreDecorator } from './enums.js';
export class ComponentBinder {
    constructor(container) {
        this.container = container;
    }
    bindComponent(componentInfo) {
        const activationHandlers = [];
        const interceptorDecorators = componentInfo.getDecorators({
            useId: CoreDecorator.INTERCEPTOR
        });
        if (interceptorDecorators.length) {
            activationHandlers.push(this.getInterceptorHandler(interceptorDecorators));
        }
        this.container.bindComponent({
            componentClass: componentInfo.getClass(),
            id: componentInfo.getId(),
            namespace: componentInfo.getOptions().namespace,
            scope: componentInfo.getOptions().scope,
            onActivation: activationHandlers
        });
    }
    bindExtensionComponent(componentInfo, extContainer) {
        this.container.bindExtensionComponent({
            componentClass: componentInfo.getClass(),
            id: componentInfo.getId(),
            namespace: componentInfo.getOptions().namespace,
            scope: componentInfo.getOptions().scope
        }, extContainer);
    }
    getInterceptorHandler(interceptorDecorators) {
        return (context, instance) => {
            const proxy = {
                get: (target, propKey) => {
                    const originalMethod = target[propKey];
                    if (typeof originalMethod !== 'function' || propKey === 'constructor')
                        return originalMethod;
                    const interceptors = this.getMethodInterceptors(interceptorDecorators, propKey, instance);
                    if (!interceptors.length)
                        return originalMethod;
                    if (isAsyncFunction(originalMethod)) {
                        return async function (...args) {
                            let result;
                            for (const interceptorInstance of interceptors) {
                                interceptorInstance.before ? await interceptorInstance.before() : true;
                            }
                            result = await originalMethod.apply(target, args);
                            for (const interceptorInstance of interceptors) {
                                interceptorInstance.after ? await interceptorInstance.after() : true;
                            }
                            return result;
                        };
                    }
                    else {
                        return function (...args) {
                            let result;
                            for (const interceptorInstance of interceptors) {
                                interceptorInstance.before ? interceptorInstance.before() : true;
                            }
                            result = originalMethod.apply(target, args);
                            for (const interceptorInstance of interceptors) {
                                interceptorInstance.after ? interceptorInstance.after() : true;
                            }
                            return result;
                        };
                    }
                }
            };
            return new Proxy(instance, proxy);
        };
    }
    getMethodInterceptors(interceptorDecorators, method, instance) {
        const decorators = interceptorDecorators.filter(decorator => !decorator.method || decorator.method === method);
        return decorators.map(decorator => {
            const key = decorator.dependencies[0].key;
            const interceptorInstance = instance[key];
            return interceptorInstance;
        });
    }
}
//# sourceMappingURL=component-binder.js.map