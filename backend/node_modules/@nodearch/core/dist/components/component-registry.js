import { ComponentBinder } from './component-binder.js';
import { ComponentInfo } from './component-info.js';
import { ComponentMetadata } from './metadata.js';
export class ComponentRegistry {
    constructor(container) {
        this.container = container;
        this.registeredComponents = [];
        this.componentBinder = new ComponentBinder(container);
    }
    get(options) {
        let components = this.getComponents(options?.id);
        if (options?.decoratorIds) {
            components = this.filterComponentsByDecoratorIds(components, options.decoratorIds);
        }
        return components;
    }
    getInfo(component) {
        let classConstructor = component instanceof Function ? component : component.constructor;
        return this.registeredComponents.find(comp => comp.getClass() === classConstructor);
    }
    getDecorators(options = {}) {
        return this
            .getComponents()
            .map(comp => {
            return comp
                .getDecorators(options)
                .map(decoInfo => {
                return {
                    ...decoInfo,
                    componentInfo: comp
                };
            });
        })
            .flat(1);
    }
    getExported() {
        return this.registeredComponents.filter(comp => comp.isExported());
    }
    register(classes) {
        classes.forEach(classConstructor => {
            const registration = ComponentMetadata.getComponentRegistration(classConstructor);
            if (!registration)
                return;
            const componentInfo = new ComponentInfo(classConstructor, registration, this.container);
            this.componentBinder.bindComponent(componentInfo);
            this.registeredComponents.push(componentInfo);
        });
    }
    registerExtension(componentRegistry, extContainer) {
        componentRegistry.getExported().forEach(componentInfo => {
            this.registeredComponents.push(componentInfo);
            this.componentBinder.bindExtensionComponent(componentInfo, extContainer);
        });
    }
    count() {
        return this.registeredComponents.length;
    }
    getComponents(id) {
        let components = [];
        if (id) {
            components = [...this.registeredComponents.filter(comp => comp.getId() === id)];
        }
        else {
            components = [...this.registeredComponents];
        }
        return components;
    }
    filterComponentsByDecoratorIds(components, decoratorIds) {
        return components.filter(comp => {
            return comp.getDecoratorsIds().some(decoId => decoratorIds.includes(decoId));
        });
    }
}
//# sourceMappingURL=component-registry.js.map