import { injectable } from 'inversify';
import { ClassInfo } from '../utils/class-info.js';
import { ComponentMetadata } from './metadata.js';
import { DecoratorType } from './enums.js';
import { generateResourceId } from '../utils/crypto.js';
export class ComponentFactory {
    static componentDecorator(options) {
        const compInfo = {
            id: options.id,
            options: options.options
        };
        return function (decoratorTarget) {
            compInfo.data = options.fn?.(decoratorTarget);
            compInfo.dependencies = options.dependencies ? ComponentFactory.getComponentDependencies({
                target: decoratorTarget,
                decoratorId: options.id,
                depsInfo: options.dependencies
            }) : [];
            ComponentMetadata.setComponentRegistration(decoratorTarget, compInfo);
            injectable()(decoratorTarget);
        };
    }
    static classDecorator(options) {
        return function (decoratorTarget) {
            const data = options.fn?.(decoratorTarget);
            ComponentMetadata.setComponentDecorator(decoratorTarget, {
                type: DecoratorType.CLASS,
                id: options.id,
                data,
                dependencies: options.dependencies ? ComponentFactory.getComponentDependencies({
                    target: decoratorTarget,
                    decoratorId: options.id,
                    depsInfo: options.dependencies
                }) : []
            });
        };
    }
    static methodDecorator(options) {
        return function (target, propKey, descriptor) {
            const decoratorTarget = target.constructor;
            const data = options.fn?.(target, propKey, descriptor);
            ComponentMetadata.setComponentDecorator(decoratorTarget, {
                type: DecoratorType.METHOD,
                id: options.id,
                method: propKey,
                data,
                dependencies: options.dependencies ? ComponentFactory.getComponentDependencies({
                    target: decoratorTarget,
                    decoratorId: options.id,
                    depsInfo: options.dependencies,
                    propKey: propKey
                }) : []
            });
        };
    }
    static parameterDecorator(options) {
        return function (target, propKey, paramIndex) {
            const decoratorTarget = target.constructor;
            const data = options.fn?.(target, propKey, paramIndex);
            ComponentMetadata.setComponentDecorator(decoratorTarget, {
                type: DecoratorType.PARAMETER,
                id: options.id,
                method: propKey,
                paramIndex: paramIndex,
                data,
                dependencies: options.dependencies ? ComponentFactory.getComponentDependencies({
                    target: decoratorTarget,
                    decoratorId: options.id,
                    depsInfo: options.dependencies,
                    propKey: propKey
                }) : []
            });
        };
    }
    static classMethodDecorator(options) {
        return function (target, propKey) {
            const decoratorTarget = propKey ? target.constructor : target;
            const data = options.fn?.(target, propKey);
            ComponentMetadata.setComponentDecorator(decoratorTarget, {
                type: DecoratorType.CLASS_METHOD,
                id: options.id,
                method: propKey,
                data,
                dependencies: options.dependencies ? ComponentFactory.getComponentDependencies({
                    target: decoratorTarget,
                    decoratorId: options.id,
                    depsInfo: options.dependencies,
                    propKey: propKey
                }) : []
            });
        };
    }
    static isComponent(component, id) {
        const registry = ComponentMetadata.getComponentRegistration(component);
        if (!registry)
            return false;
        if (id && registry.id !== id)
            return false;
        return true;
    }
    static getDecoratorInfo(classConstructor, id) {
        return ComponentMetadata
            .getComponentDecorators(classConstructor)
            .filter(x => x.id === id);
    }
    static getComponentDependencies(options) {
        let dependencies = [];
        if (options.depsInfo) {
            dependencies = ComponentFactory.addComponentDependencies(options.target, options.depsInfo);
        }
        return dependencies;
    }
    static addComponentDependencies(component, dependencies) {
        return dependencies.map(dep => {
            const key = generateResourceId();
            ClassInfo.propertyInject(component, dep, key);
            return { key, component: dep };
        });
    }
}
//# sourceMappingURL=component-factory.js.map