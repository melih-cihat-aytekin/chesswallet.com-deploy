var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
import { AppContext, Logger, Service } from '@nodearch/core';
import { SocketConfig } from './socket.config.js';
import * as IO from 'socket.io';
import http from 'http';
import https from 'https';
import { ParserService } from './parser.service.js';
import { RegistryService } from './registry.service.js';
import { ComponentFactory } from '@nodearch/core/components';
let SocketService = class SocketService {
    constructor(logger, socketConfig, parser, registryService, appContext) {
        this.logger = logger;
        this.socketConfig = socketConfig;
        this.parser = parser;
        this.registryService = registryService;
        this.appContext = appContext;
        this.server = this.initHttpServer();
        this.io = new IO.Server(this.server, socketConfig.ioOptions);
    }
    async start() {
        this.registerAdapters();
        const namespacesData = this.parser.parse();
        this.protectDefaultNamespace(namespacesData);
        this.register(this.io, namespacesData);
        if (!this.socketConfig.httpServer) {
            await this.startHttpServer();
        }
    }
    initHttpServer() {
        let server;
        if (this.socketConfig.httpServer) {
            const httpProvider = this.appContext.getContainer()
                .get(this.socketConfig.httpServer);
            if (httpProvider) {
                server = httpProvider.get();
            }
            else {
                throw new Error(`HttpServerProvider instance not found for: ${this.socketConfig.httpServer.name}`);
            }
        }
        else {
            if (this.socketConfig.server.https) {
                server = https.createServer(this.socketConfig.server.https);
            }
            else {
                server = http.createServer(this.socketConfig.server.http || {});
            }
        }
        return server;
    }
    async startHttpServer() {
        await new Promise((resolve, reject) => {
            const { port, hostname } = this.socketConfig.server;
            this.server.on('error', err => {
                err.message = 'Error starting socket.io server - ' + err.message;
                reject(err);
            });
            this.server.on('listening', () => {
                this.logger.info(`Socket.io Server running at: ${hostname}:${port}`);
                resolve(0);
            });
            try {
                this.server.listen(port, hostname);
            }
            catch (err) {
                err.message = 'Error starting socket.io server - ' + err.message;
                reject(err);
            }
        });
    }
    registerAdapters() {
        const adapter = this.socketConfig.adapter;
        if (!adapter)
            return;
        const isComponent = ComponentFactory.isComponent(adapter);
        if (isComponent) {
            const adapterInstance = this.appContext.getContainer().get(adapter);
            if (adapterInstance) {
                this.io.adapter(adapterInstance.get());
            }
            else {
                throw new Error(`Adapter instance not found for: ${adapter.name}`);
            }
        }
        else {
            this.io.adapter(adapter);
        }
    }
    protectDefaultNamespace(namespacesData) {
        let hasDefaultNamespace = false;
        namespacesData.forEach((namespaceInfo) => {
            if (namespaceInfo.name === '/') {
                hasDefaultNamespace = true;
            }
        });
        if (!hasDefaultNamespace) {
            this.io
                .of('/')
                .use((socket, next) => {
                this.logger.warn(`Default namespace not allowed - Socket ID: ${socket.id}`);
                next(new Error('Default namespace not allowed'));
            });
        }
    }
    register(io, namespaceMap) {
        namespaceMap.forEach((namespaceInfo, namespace) => {
            this.registryService.register(io, namespaceInfo, namespace);
        });
    }
    getServer() {
        return this.io;
    }
    getHttpServer() {
        return this.server;
    }
};
SocketService = __decorate([
    Service(),
    __metadata("design:paramtypes", [Logger,
        SocketConfig,
        ParserService,
        RegistryService,
        AppContext])
], SocketService);
export { SocketService };
//# sourceMappingURL=socket.service.js.map