var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
import { AppContext, Service } from '@nodearch/core';
import { SocketIODecorator } from '../enums.js';
import { DefaultNamespace } from './default-namespace.js';
import { ComponentFactory } from '@nodearch/core/components';
let ParserService = class ParserService {
    constructor(appContext) {
        this.appContext = appContext;
        this.namespacesMap = new Map();
    }
    parse() {
        const defaultNs = this.registerDefaultNamespace();
        const registry = this.appContext.getComponentRegistry();
        const subscribeDecorators = registry.getDecorators({
            id: SocketIODecorator.SUBSCRIBE
        });
        subscribeDecorators.forEach((decorator) => {
            const namespaceComponentInfo = this.getEventNamespace(decorator, defaultNs);
            this.registerEvent(namespaceComponentInfo, decorator);
        });
        this.createNamespaceDependencies();
        return this.namespacesMap;
    }
    registerDefaultNamespace() {
        const registry = this.appContext.getComponentRegistry();
        registry.register([DefaultNamespace]);
        return registry.getInfo(DefaultNamespace);
    }
    getEventNamespace(eventDecorator, defaultNs) {
        let namespaceComponentInfo = defaultNs;
        const registry = this.appContext.getComponentRegistry();
        const namespaceDecorators = eventDecorator
            .componentInfo
            .getDecorators({
            id: SocketIODecorator.NAMESPACE
        });
        let namespaceDecorator = namespaceDecorators.find((ns) => ns.method === eventDecorator.method);
        if (!namespaceDecorator) {
            namespaceDecorator = namespaceDecorators.find((ns) => !ns.method);
        }
        if (namespaceDecorator) {
            namespaceComponentInfo = registry.getInfo(namespaceDecorator.data.namespaceProvider);
        }
        return namespaceComponentInfo;
    }
    registerEvent(namespaceComponent, subscribeDecorator) {
        const event = {
            eventName: subscribeDecorator.data.eventName,
            eventMethod: subscribeDecorator.method,
            eventComponent: subscribeDecorator.componentInfo
        };
        if (this.namespacesMap.has(namespaceComponent)) {
            this.namespacesMap.get(namespaceComponent).events.push(event);
        }
        else {
            const namespaceInfo = {
                name: namespaceComponent.getData().name,
                events: [event],
                dependenciesKeys: []
            };
            this.namespacesMap.set(namespaceComponent, namespaceInfo);
        }
    }
    createNamespaceDependencies() {
        this.namespacesMap.forEach((namespaceInfo, namespace) => {
            const componentsClasses = namespaceInfo.events.map((event) => {
                return event.eventComponent.getClass();
            });
            const uniqueClasses = Array.from(new Set(componentsClasses));
            const deps = ComponentFactory.addComponentDependencies(namespace.getClass(), uniqueClasses);
            namespaceInfo.dependenciesKeys = deps;
        });
    }
};
ParserService = __decorate([
    Service(),
    __metadata("design:paramtypes", [AppContext])
], ParserService);
export { ParserService };
//# sourceMappingURL=parser.service.js.map